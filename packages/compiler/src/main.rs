//! Cortex Rust Compiler
//! 
//! A high-performance AI/ML compiler written in Rust with LLVM backend.

use clap::{Parser, Subcommand};
use std::fs;
use std::path::PathBuf;
use anyhow::{Result, Context};

mod lexer;
mod parser;
mod ast;
mod codegen;
mod error;

use lexer::Lexer;
use parser::Parser as CortexParser;
use codegen::Interpreter;
// use error::CompilerError;

#[derive(Parser)]
#[command(name = "cortexc")]
#[command(about = "Cortex Rust Compiler - High-performance AI/ML compiler")]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Build a Cortex source file to executable
    Build {
        /// Input Cortex source file
        input: PathBuf,
        /// Output executable path
        #[arg(short, long)]
        output: Option<PathBuf>,
        /// Optimization level (0-3)
        #[arg(short, long, default_value = "2")]
        opt_level: u8,
    },
    /// Run a Cortex source file directly
    Run {
        /// Input Cortex source file
        input: PathBuf,
    },
    /// Check syntax without generating code
    Check {
        /// Input Cortex source file
        input: PathBuf,
    },
    /// Format a Cortex source file
    Format {
        /// Input Cortex source file
        input: PathBuf,
        /// Output file (if not specified, overwrites input)
        #[arg(short, long)]
        output: Option<PathBuf>,
        /// Number of spaces for indentation
        #[arg(short, long, default_value = "2")]
        indent: usize,
    },
}

fn main() -> Result<()> {
    env_logger::init();
    
    let cli = Cli::parse();
    
    match cli.command {
        Commands::Build { input, output, opt_level } => {
            build_file(&input, output.map(|p| p.to_path_buf()), opt_level)
        }
        Commands::Run { input } => {
            run_file(&input)
        }
        Commands::Check { input } => {
            check_file(&input)
        }
        Commands::Format { input, output, indent } => {
            format_file(&input, output, indent)
        }
    }
}

fn build_file(input: &PathBuf, output: Option<PathBuf>, _opt_level: u8) -> Result<()> {
    let source = fs::read_to_string(input)
        .with_context(|| format!("Failed to read input file: {}", input.display()))?;
    
    // Determine output path
    let output_path = match output {
        Some(path) => path.clone(),
        None => {
            let mut path = input.clone();
            path.set_extension("");
            path
        }
    };
    
    println!("Compiling {} to {}...", input.display(), output_path.display());
    
    // For now, just interpret the source (no binary generation)
    let _result = interpret_source(&source)
        .with_context(|| format!("Failed to compile {}", input.display()))?;
    
    // Write a simple script that runs the interpreter
    let script_content = format!(
        "#!/bin/bash\n# Generated by Cortex Rust Compiler\ncortexc run {}",
        input.display()
    );
    
    fs::write(&output_path, script_content)
        .with_context(|| format!("Failed to write output file: {}", output_path.display()))?;
    
    // Make executable on Unix systems
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&output_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&output_path, perms)?;
    }
    
    println!("Successfully compiled to {}", output_path.display());
    Ok(())
}

fn run_file(input: &PathBuf) -> Result<()> {
    let source = fs::read_to_string(input)
        .with_context(|| format!("Failed to read input file: {}", input.display()))?;
    
    println!("Running {}...", input.display());
    
    // Interpret and run
    interpret_source(&source)
        .with_context(|| format!("Failed to run {}", input.display()))?;
    
    Ok(())
}

fn check_file(input: &PathBuf) -> Result<()> {
    let source = fs::read_to_string(input)
        .with_context(|| format!("Failed to read input file: {}", input.display()))?;
    
    println!("Checking syntax of {}...", input.display());
    
    // Parse only (no code generation)
    let _ast = parse_source(&source)
        .with_context(|| format!("Failed to parse {}", input.display()))?;
    
    println!("Syntax check passed!");
    Ok(())
}

fn interpret_source(source: &str) -> Result<()> {
    // Parse the source code
    let ast = parse_source(source)?;
    
    // Interpret the AST
    let mut interpreter = Interpreter::new();
    interpreter.interpret(&ast)?;
    
    Ok(())
}

fn format_file(input: &PathBuf, output: Option<PathBuf>, indent: usize) -> Result<()> {
    let source = fs::read_to_string(input)
        .with_context(|| format!("Failed to read input file: {}", input.display()))?;
    
    // Determine output path
    let output_path = match output {
        Some(path) => path.clone(),
        None => input.clone(),
    };
    
    println!("Formatting {}...", input.display());
    
    // Parse the source to validate it
    let _ast = parse_source(&source)
        .with_context(|| format!("Failed to parse {}", input.display()))?;
    
    // Format the source code
    let formatted = format_cortex_code(&source, indent);
    
    // Write the formatted code
    fs::write(&output_path, formatted)
        .with_context(|| format!("Failed to write formatted file: {}", output_path.display()))?;
    
    if output_path == *input {
        println!("Formatted: {}", input.display());
    } else {
        println!("Formatted: {} -> {}", input.display(), output_path.display());
    }
    
    Ok(())
}

fn format_cortex_code(source: &str, indent_size: usize) -> String {
    let lines: Vec<&str> = source.lines().collect();
    let mut formatted_lines = Vec::new();
    let mut current_indent = 0;
    
    for line in lines {
        let trimmed = line.trim();
        
        // Skip empty lines but preserve them
        if trimmed.is_empty() {
            formatted_lines.push(String::new());
            continue;
        }
        
        // Handle comments
        if trimmed.starts_with("//") {
            formatted_lines.push(format!("{}{}", " ".repeat(current_indent * indent_size), trimmed));
            continue;
        }
        
        // Handle block comments
        if trimmed.starts_with("/*") {
            formatted_lines.push(format!("{}{}", " ".repeat(current_indent * indent_size), trimmed));
            continue;
        }
        
        // Handle function definitions
        if trimmed.starts_with("func ") {
            formatted_lines.push(format!("{}{}", " ".repeat(current_indent * indent_size), trimmed));
            if trimmed.ends_with(" |") {
                current_indent += 1;
            }
            continue;
        }
        
        // Handle variable declarations
        if trimmed.starts_with("let ") {
            formatted_lines.push(format!("{}{}", " ".repeat(current_indent * indent_size), trimmed));
            continue;
        }
        
        // Handle control flow
        if trimmed.starts_with("if ") || trimmed.starts_with("while ") || trimmed.starts_with("for ") {
            formatted_lines.push(format!("{}{}", " ".repeat(current_indent * indent_size), trimmed));
            if trimmed.ends_with(" |") {
                current_indent += 1;
            }
            continue;
        }
        
        // Handle block endings
        if trimmed == "^" {
            if current_indent > 0 {
                current_indent -= 1;
            }
            formatted_lines.push(format!("{}{}", " ".repeat(current_indent * indent_size), trimmed));
            continue;
        }
        
        // Handle return statements
        if trimmed.starts_with("return") {
            formatted_lines.push(format!("{}{}", " ".repeat(current_indent * indent_size), trimmed));
            continue;
        }
        
        // Handle function calls and other statements
        formatted_lines.push(format!("{}{}", " ".repeat(current_indent * indent_size), trimmed));
    }
    
    formatted_lines.join("\n")
}

fn parse_source(source: &str) -> Result<ast::Program> {
    // Tokenize the source
    let mut lexer = Lexer::new(source);
    let tokens = lexer.tokenize().map_err(|_| anyhow::anyhow!("Lexer error"))?;
    
    // Parse the tokens into AST
    let mut parser = CortexParser::new(tokens);
    let ast = parser.parse()?;
    
    Ok(ast)
}
