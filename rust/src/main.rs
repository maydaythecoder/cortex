//! Cortex Rust Compiler
//! 
//! A high-performance AI/ML compiler written in Rust with LLVM backend.

use clap::{Parser, Subcommand};
use std::fs;
use std::path::PathBuf;
use anyhow::{Result, Context};

mod lexer;
mod parser;
mod ast;
mod codegen;
mod error;

use lexer::Lexer;
use parser::Parser as CortexParser;
use codegen::Interpreter;
// use error::CompilerError;

#[derive(Parser)]
#[command(name = "cortexc")]
#[command(about = "Cortex Rust Compiler - High-performance AI/ML compiler")]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Build a Cortex source file to executable
    Build {
        /// Input Cortex source file
        input: PathBuf,
        /// Output executable path
        #[arg(short, long)]
        output: Option<PathBuf>,
        /// Optimization level (0-3)
        #[arg(short, long, default_value = "2")]
        opt_level: u8,
    },
    /// Run a Cortex source file directly
    Run {
        /// Input Cortex source file
        input: PathBuf,
    },
    /// Check syntax without generating code
    Check {
        /// Input Cortex source file
        input: PathBuf,
    },
}

fn main() -> Result<()> {
    env_logger::init();
    
    let cli = Cli::parse();
    
    match cli.command {
        Commands::Build { input, output, opt_level } => {
            build_file(&input, output.map(|p| p.to_path_buf()), opt_level)
        }
        Commands::Run { input } => {
            run_file(&input)
        }
        Commands::Check { input } => {
            check_file(&input)
        }
    }
}

fn build_file(input: &PathBuf, output: Option<PathBuf>, _opt_level: u8) -> Result<()> {
    let source = fs::read_to_string(input)
        .with_context(|| format!("Failed to read input file: {}", input.display()))?;
    
    // Determine output path
    let output_path = match output {
        Some(path) => path.clone(),
        None => {
            let mut path = input.clone();
            path.set_extension("");
            path
        }
    };
    
    println!("Compiling {} to {}...", input.display(), output_path.display());
    
    // For now, just interpret the source (no binary generation)
    let _result = interpret_source(&source)
        .with_context(|| format!("Failed to compile {}", input.display()))?;
    
    // Write a simple script that runs the interpreter
    let script_content = format!(
        "#!/bin/bash\n# Generated by Cortex Rust Compiler\ncortexc run {}",
        input.display()
    );
    
    fs::write(&output_path, script_content)
        .with_context(|| format!("Failed to write output file: {}", output_path.display()))?;
    
    // Make executable on Unix systems
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&output_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&output_path, perms)?;
    }
    
    println!("Successfully compiled to {}", output_path.display());
    Ok(())
}

fn run_file(input: &PathBuf) -> Result<()> {
    let source = fs::read_to_string(input)
        .with_context(|| format!("Failed to read input file: {}", input.display()))?;
    
    println!("Running {}...", input.display());
    
    // Interpret and run
    interpret_source(&source)
        .with_context(|| format!("Failed to run {}", input.display()))?;
    
    Ok(())
}

fn check_file(input: &PathBuf) -> Result<()> {
    let source = fs::read_to_string(input)
        .with_context(|| format!("Failed to read input file: {}", input.display()))?;
    
    println!("Checking syntax of {}...", input.display());
    
    // Parse only (no code generation)
    let _ast = parse_source(&source)
        .with_context(|| format!("Failed to parse {}", input.display()))?;
    
    println!("Syntax check passed!");
    Ok(())
}

fn interpret_source(source: &str) -> Result<()> {
    // Parse the source code
    let ast = parse_source(source)?;
    
    // Interpret the AST
    let mut interpreter = Interpreter::new();
    interpreter.interpret(&ast)?;
    
    Ok(())
}

fn parse_source(source: &str) -> Result<ast::Program> {
    // Tokenize the source
    let mut lexer = Lexer::new(source);
    let tokens = lexer.tokenize().map_err(|_| anyhow::anyhow!("Lexer error"))?;
    
    // Parse the tokens into AST
    let mut parser = CortexParser::new(tokens);
    let ast = parser.parse()?;
    
    Ok(ast)
}
